/*! osc.js 2.3.0, Copyright 2019 Colin Clark | github.com/colinbdclark/osc.js */


var osc = osc || {};

!function() {
    "use strict";
    osc.SECS_70YRS = 2208988800, osc.TWO_32 = 4294967296, osc.defaults = {
        metadata: !1,
        unpackSingleArgs: !0
    }, osc.isCommonJS = !("undefined" == typeof module || !module.exports), osc.isNode = osc.isCommonJS && "undefined" == typeof window, 
    osc.isElectron = !("undefined" == typeof process || !process.versions || !process.versions.electron), 
    osc.isBufferEnv = osc.isNode || osc.isElectron, osc.isArray = function(r) {
        return r && "[object Array]" === Object.prototype.toString.call(r);
    }, osc.isTypedArrayView = function(r) {
        return r.buffer && r.buffer instanceof ArrayBuffer;
    }, osc.isBuffer = function(r) {
        return osc.isBufferEnv && r instanceof Buffer;
    }, osc.Long = "undefined" != typeof Long ? Long : osc.isNode ? require("long") : void 0, 
    osc.TextDecoder = "undefined" != typeof TextDecoder ? TextDecoder : "undefined" != typeof util && (util.TextDecoder, 
    1) ? util.TextDecoder : void 0, osc.dataView = function(r, e, t) {
        return r.buffer ? new DataView(r.buffer, e, t) : r instanceof ArrayBuffer ? new DataView(r, e, t) : new DataView(new Uint8Array(r), e, t);
    }, osc.byteArray = function(r) {
        if (r instanceof Uint8Array) return r;
        var e = r.buffer ? r.buffer : r;
        if (!(e instanceof ArrayBuffer || void 0 !== e.length && "string" != typeof e)) throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " + JSON.stringify(r, null, 2));
        return new Uint8Array(e);
    }, osc.nativeBuffer = function(r) {
        return osc.isBufferEnv ? osc.isBuffer(r) ? r : Buffer.from(r.buffer ? r : new Uint8Array(r)) : osc.isTypedArrayView(r) ? r : new Uint8Array(r);
    }, osc.copyByteArray = function(r, e, t) {
        if (osc.isTypedArrayView(r) && osc.isTypedArrayView(e)) e.set(r, t); else for (var n = void 0 === t ? 0 : t, o = Math.min(e.length - t, r.length), a = 0, i = n; a < o; a++, 
        i++) e[i] = r[a];
        return e;
    }, osc.readString = function(r, e) {
        for (var t = [], n = e.idx; n < r.byteLength; n++) {
            var o = r.getUint8(n);
            if (0 === o) {
                n++;
                break;
            }
            t.push(o);
        }
        return n = n + 3 & -4, e.idx = n, (osc.isBufferEnv ? osc.readString.withBuffer : osc.TextDecoder ? osc.readString.withTextDecoder : osc.readString.raw)(t);
    }, osc.readString.raw = function(r) {
        for (var e = "", t = 0; t < r.length; t += 1e4) e += String.fromCharCode.apply(null, r.slice(t, t + 1e4));
        return e;
    }, osc.readString.withTextDecoder = function(r) {
        var e = new Int8Array(r);
        return new osc.TextDecoder("utf-8").decode(e);
    }, osc.readString.withBuffer = function(r) {
        return Buffer.from(r).toString("utf-8");
    }, osc.writeString = function(r) {
        for (var e = r + "\0", t = e.length, n = new Uint8Array(t + 3 & -4), o = 0; o < e.length; o++) {
            var a = e.charCodeAt(o);
            n[o] = a;
        }
        return n;
    }, osc.readPrimitive = function(r, e, t, n) {
        var o = r[e](n.idx, !1);
        return n.idx += t, o;
    }, osc.writePrimitive = function(r, e, t, n, o) {
        var a;
        return o = void 0 === o ? 0 : o, e ? a = new Uint8Array(e.buffer) : (a = new Uint8Array(n), 
        e = new DataView(a.buffer)), e[t](o, r, !1), a;
    }, osc.readInt32 = function(r, e) {
        return osc.readPrimitive(r, "getInt32", 4, e);
    }, osc.writeInt32 = function(r, e, t) {
        return osc.writePrimitive(r, e, "setInt32", 4, t);
    }, osc.readInt64 = function(r, e) {
        var t = osc.readPrimitive(r, "getInt32", 4, e), n = osc.readPrimitive(r, "getInt32", 4, e);
        return osc.Long ? new osc.Long(n, t) : {
            high: t,
            low: n,
            unsigned: !1
        };
    }, osc.writeInt64 = function(r, e, t) {
        var n = new Uint8Array(8);
        return n.set(osc.writePrimitive(r.high, e, "setInt32", 4, t), 0), n.set(osc.writePrimitive(r.low, e, "setInt32", 4, t + 4), 4), 
        n;
    }, osc.readFloat32 = function(r, e) {
        return osc.readPrimitive(r, "getFloat32", 4, e);
    }, osc.writeFloat32 = function(r, e, t) {
        return osc.writePrimitive(r, e, "setFloat32", 4, t);
    }, osc.readFloat64 = function(r, e) {
        return osc.readPrimitive(r, "getFloat64", 8, e);
    }, osc.writeFloat64 = function(r, e, t) {
        return osc.writePrimitive(r, e, "setFloat64", 8, t);
    }, osc.readChar32 = function(r, e) {
        var t = osc.readPrimitive(r, "getUint32", 4, e);
        return String.fromCharCode(t);
    }, osc.writeChar32 = function(r, e, t) {
        var n = r.charCodeAt(0);
        if (!(void 0 === n || n < -1)) return osc.writePrimitive(n, e, "setUint32", 4, t);
    }, osc.readBlob = function(r, e) {
        var t = osc.readInt32(r, e), n = t + 3 & -4, o = new Uint8Array(r.buffer, e.idx, t);
        return e.idx += n, o;
    }, osc.writeBlob = function(r) {
        var e = (r = osc.byteArray(r)).byteLength, t = new Uint8Array(4 + (e + 3 & -4)), n = new DataView(t.buffer);
        return osc.writeInt32(e, n), t.set(r, 4), t;
    }, osc.readMIDIBytes = function(r, e) {
        var t = new Uint8Array(r.buffer, e.idx, 4);
        return e.idx += 4, t;
    }, osc.writeMIDIBytes = function(r) {
        r = osc.byteArray(r);
        var e = new Uint8Array(4);
        return e.set(r), e;
    }, osc.readColor = function(r, e) {
        var t = new Uint8Array(r.buffer, e.idx, 4), n = t[3] / 255;
        return e.idx += 4, {
            r: t[0],
            g: t[1],
            b: t[2],
            a: n
        };
    }, osc.writeColor = function(r) {
        var e = Math.round(255 * r.a);
        return new Uint8Array([ r.r, r.g, r.b, e ]);
    }, osc.readTrue = function() {
        return !0;
    }, osc.readFalse = function() {
        return !1;
    }, osc.readNull = function() {
        return null;
    }, osc.readImpulse = function() {
        return 1;
    }, osc.readTimeTag = function(r, e) {
        var t = osc.readPrimitive(r, "getUint32", 4, e), n = osc.readPrimitive(r, "getUint32", 4, e);
        return {
            raw: [ t, n ],
            native: 0 === t && 1 === n ? Date.now() : osc.ntpToJSTime(t, n)
        };
    }, osc.writeTimeTag = function(r) {
        var e = r.raw ? r.raw : osc.jsToNTPTime(r.native), t = new Uint8Array(8), n = new DataView(t.buffer);
        return osc.writeInt32(e[0], n, 0), osc.writeInt32(e[1], n, 4), t;
    }, osc.timeTag = function(r, e) {
        r = r || 0;
        var t = (e = e || Date.now()) / 1e3, n = Math.floor(t), o = t - n, a = Math.floor(r), i = o + (r - a);
        if (1 < i) {
            var s = Math.floor(i);
            a += s, i = i - s;
        }
        return {
            raw: [ n + a + osc.SECS_70YRS, Math.round(osc.TWO_32 * i) ]
        };
    }, osc.ntpToJSTime = function(r, e) {
        return 1e3 * (r - osc.SECS_70YRS + e / osc.TWO_32);
    }, osc.jsToNTPTime = function(r) {
        var e = r / 1e3, t = Math.floor(e), n = e - t;
        return [ t + osc.SECS_70YRS, Math.round(osc.TWO_32 * n) ];
    }, osc.readArguments = function(r, e, t) {
        var n = osc.readString(r, t);
        if (0 !== n.indexOf(",")) throw new Error("A malformed type tag string was found while reading the arguments of an OSC message. String was: " + n, " at offset: " + t.idx);
        var o = n.substring(1).split(""), a = [];
        return osc.readArgumentsIntoArray(a, o, n, r, e, t), a;
    }, osc.readArgument = function(r, e, t, n, o) {
        var a = osc.argumentTypes[r];
        if (!a) throw new Error("'" + r + "' is not a valid OSC type tag. Type tag string was: " + e);
        var i = a.reader, s = osc[i](t, o);
        return n.metadata && (s = {
            type: r,
            value: s
        }), s;
    }, osc.readArgumentsIntoArray = function(r, e, t, n, o, a) {
        for (var i = 0; i < e.length; ) {
            var s, c = e[i];
            if ("[" === c) {
                var u = e.slice(i + 1), d = u.indexOf("]");
                if (d < 0) throw new Error("Invalid argument type tag: an open array type tag ('[') was found without a matching close array tag ('[]'). Type tag was: " + t);
                var f = u.slice(0, d);
                s = osc.readArgumentsIntoArray([], f, t, n, o, a), i += d + 2;
            } else s = osc.readArgument(c, t, n, o, a), i++;
            r.push(s);
        }
        return r;
    }, osc.writeArguments = function(r, e) {
        var t = osc.collectArguments(r, e);
        return osc.joinParts(t);
    }, osc.joinParts = function(r) {
        for (var e = new Uint8Array(r.byteLength), t = r.parts, n = 0, o = 0; o < t.length; o++) {
            var a = t[o];
            osc.copyByteArray(a, e, n), n += a.length;
        }
        return e;
    }, osc.addDataPart = function(r, e) {
        e.parts.push(r), e.byteLength += r.length;
    }, osc.writeArrayArguments = function(r, e) {
        for (var t = "[", n = 0; n < r.length; n++) {
            var o = r[n];
            t += osc.writeArgument(o, e);
        }
        return t += "]";
    }, osc.writeArgument = function(r, e) {
        if (osc.isArray(r)) return osc.writeArrayArguments(r, e);
        var t = r.type, n = osc.argumentTypes[t].writer;
        if (n) {
            var o = osc[n](r.value);
            osc.addDataPart(o, e);
        }
        return r.type;
    }, osc.collectArguments = function(r, e, t) {
        osc.isArray(r) || (r = void 0 === r ? [] : [ r ]), t = t || {
            byteLength: 0,
            parts: []
        }, e.metadata || (r = osc.annotateArguments(r));
        for (var n = ",", o = t.parts.length, a = 0; a < r.length; a++) {
            var i = r[a];
            n += osc.writeArgument(i, t);
        }
        var s = osc.writeString(n);
        return t.byteLength += s.byteLength, t.parts.splice(o, 0, s), t;
    }, osc.readMessage = function(r, e, t) {
        e = e || osc.defaults;
        var n = osc.dataView(r, r.byteOffset, r.byteLength);
        t = t || {
            idx: 0
        };
        var o = osc.readString(n, t);
        return osc.readMessageContents(o, n, e, t);
    }, osc.readMessageContents = function(r, e, t, n) {
        if (0 !== r.indexOf("/")) throw new Error("A malformed OSC address was found while reading an OSC message. String was: " + r);
        var o = osc.readArguments(e, t, n);
        return {
            address: r,
            args: 1 === o.length && t.unpackSingleArgs ? o[0] : o
        };
    }, osc.collectMessageParts = function(r, e, t) {
        return t = t || {
            byteLength: 0,
            parts: []
        }, osc.addDataPart(osc.writeString(r.address), t), osc.collectArguments(r.args, e, t);
    }, osc.writeMessage = function(r, e) {
        if (e = e || osc.defaults, !osc.isValidMessage(r)) throw new Error("An OSC message must contain a valid address. Message was: " + JSON.stringify(r, null, 2));
        var t = osc.collectMessageParts(r, e);
        return osc.joinParts(t);
    }, osc.isValidMessage = function(r) {
        return r.address && 0 === r.address.indexOf("/");
    }, osc.readBundle = function(r, e, t) {
        return osc.readPacket(r, e, t);
    }, osc.collectBundlePackets = function(r, e, t) {
        t = t || {
            byteLength: 0,
            parts: []
        }, osc.addDataPart(osc.writeString("#bundle"), t), osc.addDataPart(osc.writeTimeTag(r.timeTag), t);
        for (var n = 0; n < r.packets.length; n++) {
            var o = r.packets[n], a = (o.address ? osc.collectMessageParts : osc.collectBundlePackets)(o, e);
            t.byteLength += a.byteLength, osc.addDataPart(osc.writeInt32(a.byteLength), t), 
            t.parts = t.parts.concat(a.parts);
        }
        return t;
    }, osc.writeBundle = function(r, e) {
        if (!osc.isValidBundle(r)) throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. Bundle was: " + JSON.stringify(r, null, 2));
        e = e || osc.defaults;
        var t = osc.collectBundlePackets(r, e);
        return osc.joinParts(t);
    }, osc.isValidBundle = function(r) {
        return void 0 !== r.timeTag && void 0 !== r.packets;
    }, osc.readBundleContents = function(r, e, t, n) {
        for (var o = osc.readTimeTag(r, t), a = []; t.idx < n; ) {
            var i = osc.readInt32(r, t), s = t.idx + i, c = osc.readPacket(r, e, t, s);
            a.push(c);
        }
        return {
            timeTag: o,
            packets: a
        };
    }, osc.readPacket = function(r, e, t, n) {
        var o = osc.dataView(r, r.byteOffset, r.byteLength);
        n = void 0 === n ? o.byteLength : n, t = t || {
            idx: 0
        };
        var a = osc.readString(o, t), i = a[0];
        if ("#" === i) return osc.readBundleContents(o, e, t, n);
        if ("/" === i) return osc.readMessageContents(a, o, e, t);
        throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string. Header was: " + a);
    }, osc.writePacket = function(r, e) {
        if (osc.isValidMessage(r)) return osc.writeMessage(r, e);
        if (osc.isValidBundle(r)) return osc.writeBundle(r, e);
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle. Packet was: " + JSON.stringify(r, null, 2));
    }, osc.argumentTypes = {
        i: {
            reader: "readInt32",
            writer: "writeInt32"
        },
        h: {
            reader: "readInt64",
            writer: "writeInt64"
        },
        f: {
            reader: "readFloat32",
            writer: "writeFloat32"
        },
        s: {
            reader: "readString",
            writer: "writeString"
        },
        S: {
            reader: "readString",
            writer: "writeString"
        },
        b: {
            reader: "readBlob",
            writer: "writeBlob"
        },
        t: {
            reader: "readTimeTag",
            writer: "writeTimeTag"
        },
        T: {
            reader: "readTrue"
        },
        F: {
            reader: "readFalse"
        },
        N: {
            reader: "readNull"
        },
        I: {
            reader: "readImpulse"
        },
        d: {
            reader: "readFloat64",
            writer: "writeFloat64"
        },
        c: {
            reader: "readChar32",
            writer: "writeChar32"
        },
        r: {
            reader: "readColor",
            writer: "writeColor"
        },
        m: {
            reader: "readMIDIBytes",
            writer: "writeMIDIBytes"
        }
    }, osc.inferTypeForArgument = function(r) {
        switch (typeof r) {
          case "boolean":
            return r ? "T" : "F";

          case "string":
            return "s";

          case "number":
            return "f";

          case "undefined":
            return "N";

          case "object":
            if (null === r) return "N";
            if (r instanceof Uint8Array || r instanceof ArrayBuffer) return "b";
            if ("number" == typeof r.high && "number" == typeof r.low) return "h";
        }
        throw new Error("Can't infer OSC argument type for value: " + JSON.stringify(r, null, 2));
    }, osc.annotateArguments = function(r) {
        for (var e = [], t = 0; t < r.length; t++) {
            var n, o = r[t];
            if ("object" == typeof o && o.type && void 0 !== o.value) n = o; else if (osc.isArray(o)) n = osc.annotateArguments(o); else {
                n = {
                    type: osc.inferTypeForArgument(o),
                    value: o
                };
            }
            e.push(n);
        }
        return e;
    }, osc.isCommonJS && (module.exports = osc);
}();